// 问题描述
// 给定三种珠子：00(n个)、01(m个)、11(k个)，要在环形字符串S上找到最长的连续子串，使得能用现有珠子完成这个子串。

// 关键约束
// 珠子可翻转：01珠子可以变成10
// 环形字符串：首尾相接
// 连续覆盖：珠子必须连续放置，每个珠子覆盖相邻两个字符
// 解题思路
// 核心算法：双指针滑动窗口
// 分奇偶处理：珠子长度为2，需要分别从奇数和偶数位置开始
// 滑动窗口：对每种起始位置用双指针扩展最长可行区间
// 巧妙的编码设计
// 编码映射：

// 00 → 0 (b=0时) 或 3 (b=1时)
// 01/10 → 1 (b=0时) 或 4 (b=1时) — 关键：统一编码！
// 11 → 2 (b=0时) 或 5 (b=1时)
// 算法流程
// 初始化：将珠子数量复制到ans数组的前6位
// 两轮处理：
// 第一轮(t=1)：处理奇数起始位置 1,3,5...
// 第二轮(t=0)：处理偶数起始位置 0,2,4...
// 滑动窗口：
// 右指针扩展：消耗珠子
// 左指针收缩：归还珠子
// 记录最大长度
// 算法优势
// 时间复杂度：O(|S|) - 线性时间
// 空间复杂度：O(1) - 常数空间
// 处理翻转：编码统一处理01和10
// 处理环形：字符串加倍 + 模运算
// 关键洞察
// 珠子翻转通过编码统一处理，01和10映射到同一索引
// 分奇偶确保所有可能的珠子放置方案都被考虑
// 双指针保证每个位置最多访问常数次，效率极高
#include <bits/stdc++.h>
using namespace std;

void solve(){
    vector<int> v(3);
    for(int i = 0;i<3;i++)  cin>>v[i];
    vector<int> ans(10);
    for(int i = 0;i<6;i++){
        ans[i] = v[i%3];
    }
    string s;cin>>s;
    int x = s.size();
    s = s+s;
    int res = 0;
    int t = 2;

    auto make_idx = [&](int a,int b) -> int {
        return s[a]-'0'+s[a+1]-'0'+ b*3;
    };
    while(t--){
        for(int l = t,r = t;l<x;l+=2){
            while(r+2<=x+l &&  ans[make_idx(r,t)]!=0){
                ans[make_idx(r,t)]--;
                r+=2;
            }
            res = max(res,r-l);
            ans[make_idx(l,t)]++;
        }
    }
    cout<<res<<endl;
}

signed main() {
    cin.tie(0)->ios_base::sync_with_stdio(0);
    int _ = 1;
    // cin>>t;
    while(_--){
        solve();
    }
    return 0;
}

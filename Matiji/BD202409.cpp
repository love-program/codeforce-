/*核心思想：最大盘子的移动点
首先，我们考虑 n 个盘子中最大的那个，即第 n 号盘。
在将 n 个盘子从 A 移动到 C 的标准解法中：
前 2^(n-1) - 1 步：是将 n-1 个小盘子从 A 移动到 B（辅助杆）。
第 2^(n-1) 步：是将第 n 号盘从 A 移动到 C。这是它唯一的一次移动。
后 2^(n-1) - 1 步：是将 n-1 个小盘子从 B 移动到 C。
这个**“中间步骤”** 是关键。任何一个步数 k，我们都可以通过它和 2^(n-1) 的大小关系，来判断第 n 号盘动了没有。
2. 与二进制的关系
现在，我们来看步数 k 的二进制表示，也就是输入的字符串 s。这个字符串有 n 位。
2^(n-1) 的二进制是什么？它是一个 1 后面跟着 n-1 个 0。例如，n=4, 2^3=8，二进制就是 1000。
所有小于 2^(n-1) 的数，它们的二进制表示中，最高位（第1位，也就是索引为 0 的位 s[0]）一定是 0。
所有大于等于 2^(n-1) 的数，它们的二进制表示中，最高位一定是 1。
*/
#include<bits/stdc++.h> 

using namespace std;
const int N = 1e5 + 10;
int n;
char s[N];
char ans[N];

// 您的递归函数是完全正确的。
// A, B, C 分别代表当前子问题的 源、辅助、目标 杆。
// k 代表当前处理的是第 k 大的盘子。
void dfs(char A, char B, char C, int k)
{
    if(k == 0)
        return;

    // s[n-k] 是与第 k 大的盘子对应的二进制位
    // （s[0]对应n号盘，s[1]对应n-1号盘...）
    if(s[n-k] != '1')
    {
        // 该位为0，意味着在k个盘子的子问题中，我们还没执行到移动第k大盘子的那一步。
        // 所以第k大盘子仍然在它的“源”杆A上。
        ans[k] = A;
        // 剩下的k-1个盘子的任务，是"从A移动到B"，所以目标是B，辅助是C。
        dfs(A, C, B, k-1);
    }
    else { // s[n-k] == '1'
        // 该位为1，意味着第k大盘子已经完成了移动。
        // 所以它在它的“目标”杆C上。
        ans[k] = C;
        // 剩下的k-1个盘子的任务，是"从B移动到C"，所以源是B，辅助是A。
        dfs(B, A, C, k-1);
    }
}

int main()
{
    // 修改了这里的输入方式
    scanf("%d", &n);
    scanf("%s", s);

    char A = 'A';
    char B = 'B';
    char C = 'C';
    
    // 您的逻辑从这里开始是完美的
    dfs(A, B, C, n);
    
    // ans数组是从1到n被赋值的
    for(int i = 1; i <= n; i++)
    {
        printf("%c", ans[i]);
    }
    printf("\n"); // 加上换行是一个好习惯
    
    return 0;
}